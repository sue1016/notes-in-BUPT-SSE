# 并发控制 concurrency control
> 统一提交给dbms的那么多任务，怎么控制他们不干扰 
> 为什么要并发控制  

### 三种数据不一致现象     
* 丢失修改  
          
          a用户发出请求，读出x余额，减十块，写回去  
          同时    
          b用户发出请求，读出x余额，加一百块，写回去 
* 脏读（未提交依赖）  
  
          b比a稍微快一点点   
          a读了一个修改了之后但是还没提交的数据（脏的数据）  
          万一a没提交呢？万一人家突然崩了呢？全部roll back了呢？
* 不可重复读   

          a用户转账业务，将x里的余额转到z里的余额   
          b用户统计x,y,z的和，只读事务，本来和不会变，但是  
          
          没太懂   

> 那如何控制数据一致呢  

### 可串行性和可恢复性    
> 尽可能排队，但是排队的话，并行度差，后台浪费，前台用户体验感差    
> 解决方案======>  
> 如何判断打架不打架    
> 标志的相容和相斥   
> 打架的时候 ==> 等等    
> 不打架的时候 ==> 并行  

#### 调度schedule  
事务的执行顺序  
串行调度serial --  全部排队  
非串行调度nonserial -- 可以交叉执行  

####  锁和时间戳  
<font color=red>时间戳不讲，不考，可以不看</font>   
锁是加载在数据项上的标志  
锁的颗粒度有多大（是一列还是一行是一个表还是一个库） 

##### 锁的类型   

* 读/共享锁 shared lock  
  
            我在上面加了这个锁的话，你也可以加   
            select...     
            发送了一个select，在要select的对象上加了一个读锁  
  
* 写/排他/独占锁  exclusive lock  

            我在上面加了这个锁之后，你啥锁也不能加  
            update delete...   
            发送了一个update delete...，在要update delete...的对象上加了一个写锁   
读锁和读锁相容，读锁和写锁，写锁和写锁不想容
所有的锁都在commit之后才释放  
##### 两段锁协议  
遵循两段锁协议的一定可串行，可避免3种不一致问题      
所有的事务能找到一个分割点，上面是加锁的过程，下面是解锁的过程   
所有的加锁都在第 一个解锁之前，第一个解锁之后就没有加锁了

